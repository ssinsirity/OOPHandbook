{
  "topics": [
    {
      "name": "Концепти ООП",
      "number": 1,
      "units": [
        {
          "name": "Концепти ООП у Java",
          "number": 1,
          "content": [
            {
              "data": "Концепції ООП включають наступні концепції об'єктно-орієнтованого програмування:\n\n     - Об'єкт\n     - Клас\n     - Абстракція\n     - Інкапсуляція\n     - Наслідування\n     - Поліморфізм",
              "type": "text",
              "position": 1
            }
          ]
        },
        {
          "name": "Об'єкт",
          "number": 2,
          "content": [
            {
              "data": "Об’єкт можна представити як сутність, яка має стан і поведінку. Наприклад: автомобіль – це об’єкт, який має такі стани, як колір, модель, ціна та поведінка, наприклад швидкість, старт, перемикання передач, зупинка тощо.",
              "type": "text",
              "position": 1
            },
            {
              "data": "Давайте зрозуміємо різницю між станом і поведінкою. Стан об’єкта – це елемент даних, який можна представити у значеннях, таких як ціна автомобіля, колір, розглядати їх як змінні в програмуванні. Поведінка схожа на метод класу, це група дій, які разом можуть виконувати завдання. Наприклад, перемикання передач – це поведінка, оскільки воно включає в себе кілька підзавдань, таких як контроль швидкості, зчеплення, переміщення ручки коробки передач.",
              "type": "text",
              "position": 2
            },
            {
              "data": "Приклад 1:\nКлас: Будинок\nСтан: адреса, колір, область\nПоведінка: відкрити двері, закрити двері\n\nДавайте подивимося, як ми можемо записати ці стани та поведінку в програмі на Java. Стани можуть бути представлені як змінні екземпляра, а поведінка як методи класу.",
              "type": "text",
              "position": 3
            },
            {
              "data": "class House {\n   String address;\n   String color;\n   double area;\n   void openDoor() {\n      // код\n   }\n   void closeDoor() {\n      // код\n   }\n ...\n ...\n}",
              "type": "code",
              "position": 4
            },
            {
              "data": "Приклад 2:\nКлас: Автомобіль\nСтан: колір, бренд, вага, модель\nПоведінка: гальмування, прискорення, сповільнення, зміна передач.\n\nПримітка. Як ми бачили в наведеному вище прикладі, стани та поведінка об’єкта можуть бути представлені змінними та методами в класі.",
              "type": "text",
              "position": 5
            }
          ]
        },
        {
          "name": "Клас",
          "number": 3,
          "content": [
            {
              "data": "Клас можна розглядати як план, який ви можете використовувати для створення скільки завгодно об’єктів. Наприклад, у нас є клас Website, який має два члени даних. Це лише схема, вона не представляє жодного веб-сайту, однак за допомогою цього ми можемо створити об’єкти Website, які представляють веб-сайти. Ми створили два об’єкти, створюючи об’єкти, ми надавали окремі властивості об’єктам за допомогою конструктора.",
              "type": "text",
              "position": 1
            },
            {
              "data": "public class Website {\n   // поля\n   String webName;\n   int webAge;\n\n   // конструктор\n   Website(String name, int age){\n      this.webName = name;\n      this.webAge = age;\n   }\n   public static void main(String args[]){\n      // створення об'єктів\n      Website obj1 = new Website(\"beginnersbook\", 11);\n      Website obj2 = new Website(\"google\", 28);\n\n     // доступ до об'єктів через посилання\n     System.out.println(obj1.webName+\" \"+obj1.webAge); // beginnersbook 11\n     System.out.println(obj2.webName+\" \"+obj2.webAge) // google 28;\n   }\n}",
              "type": "code",
              "position": 2
            }
          ]
        },
        {
          "name": "Абстракція",
          "number": 4,
          "content": [
            {
              "data": "Абстракція – це процес, у якому ви показуєте лише «релевантні» дані та «ховаєте» непотрібні деталі об’єкта від користувача. Наприклад, коли ви входите на свій банківський рахунок онлайн, ви вводите свій ідентифікатор користувача та пароль і натискаєте «Вхід». Що відбувається, коли ви натискаєте «Вхід», як вхідні дані надсилаються на сервер, як вони перевіряються, усе це абстрагується від вас",
              "type": "text",
              "position": 1
            },
            {
              "data": "Приклад абстрактного класу:\nТут ми маємо абстрактний клас Animal, який має абстрактний метод animalSound(), оскільки звуки тварин відрізняються від однієї тварини до іншої, немає сенсу надавати реалізацію цьому методу, оскільки кожен дочірній клас повинен перевизначати цей метод, щоб надати власний деталі реалізації. Тому ми зробили його абстрактним.\n\nТепер кожна тварина повинна мати звук. Зробивши цей метод абстрактним, ми зробили для дочірнього класу обов’язковим надання деталей реалізації цього методу. Таким чином ми гарантуємо, що кожна тварина має звук.",
              "type": "text",
              "position": 2
            },
            {
              "data": "// абстрактний клас\nabstract class Animal{\n   // абстрактний метод\n   public abstract void animalSound();\n}\npublic class Dog extends Animal{\n\n   public void animalSound(){\n\tSystem.out.println(\"Woof\");\n   }\n   public static void main(String args[]){\n\tAnimal obj = new Dog();\n\tobj.animalSound(); // Woof\n   }\n}",
              "type": "code",
              "position": 3
            }
          ]
        },
        {
          "name": "Інкапсуляція",
          "number": 5,
          "content": [
            {
              "data": "Інкапсуляція просто означає зв’язування стану об’єкта (полів) і поведінки (методів) разом. Якщо ви створюєте клас, ви виконуєте інкапсуляцію.",
              "type": "text",
              "position": 1
            },
            {
              "data": "Приклад\n1) Зробіть змінні екземпляра приватними, щоб до них не можна було отримати прямий доступ поза класом. Ви можете встановити та отримати значення цих змінних лише за допомогою методів класу.\n2) Мати методи getter і setter у класі для встановлення та отримання значень полів.",
              "type": "text",
              "position": 2
            },
            {
              "data": "class EmployeeCount {\n   private int numOfEmployees = 0;\n   public void setNoOfEmployees(int count) {\n       numOfEmployees = count;\n   }\n   public double getNoOfEmployees() {\n       return numOfEmployees;\n   }\n}\npublic class EncapsulationExample {\n   public static void main(String args[]) {\n      EmployeeCount obj = new EmployeeCount();\n      obj.setNoOfEmployees(5613);\n      System.out.println(\"No Of Employees: \"+(int)obj.getNoOfEmployees()); // No of Employees: 5613\n    }\n}",
              "type": "code",
              "position": 3
            },
            {
              "data": "Клас EncapsulationExample, який використовує об’єкт класу EmployeeCount, не зможе безпосередньо отримати NoOfEmployees. Для встановлення та отримання значення він повинен використовувати методи встановлення та отримання одного класу.\n\nЯка перевага використання інкапсуляції в програмуванні на Java?\nЩо ж, у якийсь момент часу, якщо ви захочете змінити деталі реалізації класу EmployeeCount, ви можете вільно це зробити, не впливаючи на класи, які його використовують.",
              "type": "text",
              "position": 4
            }
          ]
        },
        {
          "name": "Наслідування",
          "number": 6,
          "content": [
            {
              "data": "Процес, за допомогою якого один клас набуває властивостей і функцій іншого класу, називається успадкуванням. Успадкування забезпечує ідею повторного використання коду, і кожен підклас визначає лише ті функції, які є унікальними для нього, решта функцій можуть бути успадковані від батьківського класу.\n\nУспадкування — це процес визначення нового класу на основі існуючого класу шляхом розширення його загальних членів даних і методів.\nСпадкування дозволяє нам повторно використовувати код, це покращує повторне використання у вашій програмі Java.\nБатьківський клас називається базовим або суперкласом. Дочірній клас, який розширює базовий клас, називається похідним класом, підкласом або дочірнім класом.\nПримітка. Найбільша перевага успадкування полягає в тому, що код базового класу не потрібно переписувати в дочірньому класі.\nЗмінні та методи базового класу також можна використовувати в дочірньому класі.\n\nСинтаксис: успадкування в Java\nЩоб успадкувати клас, ми використовуємо ключове слово extends. Тут клас A є дочірнім класом, а клас B є батьківським.",
              "type": "text",
              "position": 1
            },
            {
              "data": "class A extends B\n{\n}",
              "type": "code",
              "position": 2
            },
            {
              "data": "Приклад успадкування\nУ цьому прикладі ми маємо батьківський клас Teacher і дочірній клас MathTeacher. У класі MathTeacher нам не потрібно писати той самий код, який уже присутній у поточному класі. Тут ми маємо назву коледжу, позначення та метод does(), який є спільним для всіх викладачів, тому класу MathTeacher не потрібно писати цей код, загальні дані та методи можна успадкувати від класу Teacher.",
              "type": "text",
              "position": 3
            },
            {
              "data": "class Teacher {\n   String designation = \"Teacher\";\n   String college = \"Beginnersbook\";\n   void does(){\n\tSystem.out.println(\"Teaching\");\n   }\n}\npublic class MathTeacher extends Teacher{\n   String mainSubject = \"Maths\";\n   public static void main(String args[]){\n      MathTeacher obj = new MathTeacher();\n      System.out.println(obj.college); // Beginnersbook\n      System.out.println(obj.designation); // Teacher\n      System.out.println(obj.mainSubject); // Maths\n      obj.does() // Teaching;\n   }\n}",
              "type": "code",
              "position": 4
            }
          ]
        },
        {
          "name": "Поліморфізм",
          "number": 7,
          "content": [
            {
              "data": "Поліморфізм — це функція об’єктно-орієнтованого програмування, яка дозволяє нам виконувати одну дію різними способами. Наприклад, скажімо, у нас є клас Animal, який має метод animalSound(), тут ми не можемо реалізувати цей метод, оскільки ми не знаємо, який клас Animal розширить клас Animal. Отже, ми робимо цей метод абстрактним так:",
              "type": "text",
              "position": 1
            },
            {
              "data": "public abstract class Animal{\n   ...\n   public abstract void animalSound();\n}",
              "type": "code",
              "position": 2
            },
            {
              "data": "Тепер припустімо, що у нас є два класи Animal Dog і Lion, які розширюють клас Animal. Ми можемо надати деталі реалізації там.",
              "type": "text",
              "position": 3
            },
            {
              "data": "public class Lion extends Animal{\n...\n    @Override\n    public void animalSound(){\n        System.out.println(\"Roar\");\n    }\n}",
              "type": "code",
              "position": 4
            },
            {
              "data": "public class Dog extends Animal{\n...\n    @Override\n    public void animalSound(){\n        System.out.println(\"Woof\");\n    }\n}",
              "type": "code",
              "position": 5
            },
            {
              "data": "Як ви бачите, хоча у нас була спільна дія для всіх підкласів animalSound(), але були різні способи виконання однієї дії. Це чудовий приклад поліморфізму (функції, яка дозволяє нам виконувати одну дію різними способами).",
              "type": "text",
              "position": 6
            }
          ]
        }
      ]
    },
    {
      "name": "Конструктор",
      "number": 2,
      "units": [
        {
          "name": "Що це?",
          "number": 1,
          "content": [
            {
              "data": "Конструктор - це блок коду, який ініціалізує новостворений об'єкт. Конструктор нагадує метод екземпляра в Java, але це не метод, оскільки він не має типу повернення. Коротше кажучи, конструктор і метод відрізняються (докладніше про це в кінці цього посібника). Люди часто називають конструктор спеціальним типом методу в Java.\n\nКонструктор має таке ж ім’я, як і клас, і виглядає так у коді Java.",
              "type": "text",
              "position": 1
            },
            {
              "data": "public class MyClass{\n   // Це конструктор\n   MyClass(){\n   }\n   ..\n}",
              "type": "code",
              "position": 1
            }
          ]
        },
        {
          "name": "Як конструктор працює?",
          "number": 2,
          "content": [
            {
              "data": "Щоб зрозуміти роботу конструктора, розглянемо приклад. скажімо, у нас є клас MyClass.\nКоли ми створюємо об’єкт MyClass таким чином:",
              "type": "text",
              "position": 1
            },
            {
              "data": "MyClass obj = new MyClass()",
              "type": "code",
              "position": 2
            },
            {
              "data": "Ключове слово new тут створює об’єкт класу MyClass і викликає конструктор для ініціалізації цього щойно створеного об’єкта.\n\nТут ми створили об’єкт obj класу Hello, а потім відобразили назву змінної екземпляра об’єкта. Як ви бачите, результатом є BeginnersBook.com, саме те, що ми передали в назву під час ініціалізації в конструкторі. Це показує, що коли ми створили об’єкт obj, був викликаний конструктор. У цьому прикладі ми використали це ключове слово, яке посилається на поточний об’єкт, об’єкт obj у цьому прикладі. Ми детально розглянемо це ключове слово в наступному посібнику.",
              "type": "text",
              "position": 3
            },
            {
              "data": "public class Hello {\n   String name;\n   // Конструктор\n   Hello(){\n      this.name = \"BeginnersBook.com\";\n   }\n   public static void main(String[] args) {\n      Hello obj = new Hello();\n      System.out.println(obj.name);\n   }\n}",
              "type": "code",
              "position": 4
            },
            {
              "data": "Результат:\n\nBeginnersBook.com",
              "type": "text",
              "position": 5
            }
          ]
        },
        {
          "name": "Конструктор за замовчуванням",
          "number": 3,
          "content": [
            {
              "data": "Якщо ви не реалізуєте жодного конструктора у своєму класі, компілятор Java вставляє конструктор за замовчуванням у ваш код від вашого імені. Цей конструктор відомий як конструктор за замовчуванням. Ви не знайдете його у вихідному коді (файлі java), оскільки він буде вставлений у код під час компіляції та існує у файлі .class",
              "type": "text",
              "position": 1
            }
          ]
        },
        {
          "name": "Конструктор без параметрів",
          "number": 4,
          "content": [
            {
              "data": "Конструктор без аргументів відомий як конструктор без аргументів. Підпис такий самий, як у конструктора за замовчуванням, однак тіло може мати будь-який код на відміну від конструктора за замовчуванням, де тіло конструктора порожнє.",
              "type": "text",
              "position": 1
            },
            {
              "data": "class Demo\n{\n     public Demo()\n     {\n         System.out.println(\"Це конструктор без параметрів\");\n     }\n     public static void main(String args[]) {\n    \t new Demo();\n     }\n}",
              "type": "code",
              "position": 2
            },
            {
              "data": "Результат:\nЦе конструктор без параметрів",
              "type": "text",
              "position": 3
            }
          ]
        },
        {
          "name": "Конструктор з параметрами",
          "number": 5,
          "content": [
            {
              "data": "Конструктор з аргументами (або, можна сказати, параметрами) відомий як параметризований конструктор.\n\nПриклад: параметризований конструктор\nУ цьому прикладі ми маємо параметризований конструктор із двома параметрами id та name. Під час створення об’єктів obj1 і obj2 я передав два аргументи, щоб цей конструктор викликався після створення obj1 і obj2.",
              "type": "text",
              "position": 1
            },
            {
              "data": "public class Employee {\n\n   int empId;  \n   String empName;  \n\t    \n   // Конструктор з двома параметрами\n   Employee(int id, String name){  \n       this.empId = id;  \n       this.empName = name;  \n   }  \n   void info(){\n        System.out.println(\"Id: \"+empId+\" Name: \"+empName);\n   }  \n\t   \n   public static void main(String args[]){  \n\tEmployee obj1 = new Employee(10245,\"Chaitanya\");  \n\tEmployee obj2 = new Employee(92232,\"Negan\");  \n\tobj1.info();  \n\tobj2.info();  \n   }  \n}",
              "type": "code",
              "position": 2
            },
            {
              "data": "Результат:\n\nId: 10245 Name: Chaitanya\nId: 92232 Name: Negan",
              "type": "text",
              "position": 3
            }
          ]
        },
        {
          "name": "Ключове слово super()",
          "number": 6,
          "content": [
            {
              "data": "Щоразу, коли конструктор дочірнього класу викликається, він неявно викликає конструктор батьківського класу. Ви також можете сказати, що компілятор вставляє super(); оператор на початку конструктора дочірнього класу.",
              "type": "text",
              "position": 1
            },
            {
              "data": "Щоразу, коли конструктор дочірнього класу викликається, він неявно викликає конструктор батьківського класу. Ви також можете сказати, що компілятор вставляє super(); оператор на початку конструктора дочірнього класу.Щоразу, коли конструктор дочірнього класу викликається, він неявно викликає конструктор батьківського класу. Ви також можете сказати, що компілятор вставляє super(); оператор на початку конструктора дочірнього класу.",
              "type": "text",
              "position": 2
            },
            {
              "data": "Результат:\n\nMyParentClass Constructor\nMyChildClass Constructor",
              "type": "text",
              "position": 3
            }
          ]
        },
        {
          "name": "Перевантаження конструктора",
          "number": 7,
          "content": [
            {
              "data": "Перевантаження конструктора — це концепція наявності кількох конструкторів із різними списками параметрів таким чином, що кожен конструктор виконує інше завдання.",
              "type": "text",
              "position": 1
            }
          ]
        }
      ]
    },
    {
      "name": "Клас String",
      "number": 3,
      "units": [
        {
          "name": "Що це?",
          "number": 1,
          "content": [
            {
              "data": "",
              "type": "",
              "position": 1
            }
          ]
        },
        {
          "name": "Рядковий літерал",
          "number": 2,
          "content": [
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            }
          ]
        },
        {
          "name": "Використання ключового слова new",
          "number": 3,
          "content": [
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            }
          ]
        },
        {
          "name": "Приклади програм",
          "number": 4,
          "content": [
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            },
            {
              "data": "",
              "type": "",
              "position": 1
            }
          ]
        },
        {
          "name": "Методи класу",
          "number": 5,
          "content": [
            {
              "data": "",
              "type": "",
              "position": 1
            }
          ]
        }
      ]
    },
    {
      "name": "Ключове слово static",
      "number": 4,
      "units": []
    },
    {
      "name": "Наслідування",
      "number": 5,
      "units": []
    },
    {
      "name": "Види наслідувань",
      "number": 6,
      "units": []
    },
    {
      "name": "Агрегація",
      "number": 7,
      "units": []
    },
    {
      "name": "Асоціація",
      "number": 8,
      "units": []
    },
    {
      "name": "Ключове слово super",
      "number": 9,
      "units": []
    },
    {
      "name": "Перевантаження методів",
      "number": 10,
      "units": []
    },
    {
      "name": "Перевизначення методів",
      "number": 11,
      "units": []
    },
    {
      "name": "Перевантаження vs перевизначення",
      "number": 12,
      "units": []
    },
    {
      "name": "Поліформізм",
      "number": 13,
      "units": []
    },
    {
      "name": "Види поліформізму",
      "number": 14,
      "units": []
    },
    {
      "name": "Статична та динамічна прив'язка",
      "number": 15,
      "units": []
    },
    {
      "name": "Абстрактний клас та методи",
      "number": 16,
      "units": []
    },
    {
      "name": "Інтерфейс",
      "number": 17,
      "units": []
    },
    {
      "name": "Абстрактний клас vs інтерфейс",
      "number": 18,
      "units": []
    },
    {
      "name": "Інкапсуляція",
      "number": 19,
      "units": []
    },
    {
      "name": "Пакети",
      "number": 20,
      "units": []
    },
    {
      "name": "Модифікатори доступу",
      "number": 21,
      "units": []
    },
    {
      "name": "Прибирач сміття",
      "number": 22,
      "units": []
    },
    {
      "name": "Внутрішні класи",
      "number": 23,
      "units": []
    },
    {
      "name": "Статичний імпорт",
      "number": 24,
      "units": []
    },
    {
      "name": "Статичний конструктор",
      "number": 25,
      "units": []
    }
  ]
}